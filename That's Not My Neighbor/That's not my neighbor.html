<script src="That's not my neighbor.js"></script>
<script>
const GODOT_CONFIG = {"args":[],"canvasResizePolicy":2,"executable":"That's not my neighbor","experimentalVK":false,"fileSizes":{"That's not my neighbor.pck":274979280,"That's not my neighbor.wasm":48954223},"focusCanvas":true,"gdextensionLibs":[]};

// --- CONFIG: change these to match how many parts you have and the base name ---
const BASE_PCK_NAME = "That's not my neighbor.pck";
const PART_COUNT = 6; // set this to however many .part files you created (game.pck.part1 .. partN)
// ---------------------------------------------------------------------------

/**
 * Fetch all parts in order and combine them into one ArrayBuffer.
 * Expects files named "<BASE_PCK_NAME>.part1", "<BASE_PCK_NAME>.part2", ...
 */
async function fetchAndCombineParts(baseName, totalParts, onProgress) {
	try {
		const buffers = new Array(totalParts);
		let loaded = 0;
		for (let i = 1; i <= totalParts; i++) {
			const partName = `${baseName}.part${i}`;
			const res = await fetch(encodeURI(partName));
			if (!res.ok) throw new Error(`Failed to load ${partName}: ${res.status} ${res.statusText}`);
			const ab = await res.arrayBuffer();
			buffers[i - 1] = ab;
			loaded++;
			if (onProgress) onProgress(loaded, totalParts);
		}

		const totalSize = buffers.reduce((acc, b) => acc + b.byteLength, 0);
		const combined = new Uint8Array(totalSize);
		let offset = 0;
		for (const b of buffers) {
			combined.set(new Uint8Array(b), offset);
			offset += b.byteLength;
		}
		return combined.buffer;
	} catch (e) {
		throw e;
	}
}

/**
 * Intercept window.fetch requests for the original pck name and respond with combinedBuffer.
 * Also provides a basic interception for XHR by faking a response when .responseType === '' or 'arraybuffer'.
 */
function installInterceptors(originalPckName, combinedBufferPromise) {
	// Normalize URL check to only filename matching (handles relative paths)
	const normalizedTarget = originalPckName;

	// --- fetch patch ---
	const _originalFetch = window.fetch;
	window.fetch = async function(resource, init) {
		try {
			const url = (typeof resource === 'string') ? resource : String(resource && resource.url);
			// crude match on filename â€” encodeURI in requests may differ, so check decode too
			const decoded = decodeURIComponent(url.split('/').pop() || url);
			if (decoded === normalizedTarget) {
				const buf = await combinedBufferPromise;
				return new Response(buf, {
					status: 200,
					statusText: "OK",
					headers: {
						'Content-Type': 'application/octet-stream',
						'Content-Length': String(buf.byteLength)
					}
				});
			}
		} catch (e) {
			console.warn("fetch interceptor error:", e);
		}
		return _originalFetch.apply(this, arguments);
	};

	// --- XHR patch (simple) ---
	// Many libs use XHR; we intercept open/send to return combined buffer synchronously via onload when requested.
	const _origXhrOpen = XMLHttpRequest.prototype.open;
	const _origXhrSend = XMLHttpRequest.prototype.send;
	XMLHttpRequest.prototype.open = function(method, url) {
		this._intercept_url = url;
		return _origXhrOpen.apply(this, arguments);
	};
	XMLHttpRequest.prototype.send = function(body) {
		try {
			const url = this._intercept_url ? String(this._intercept_url) : '';
			const decoded = decodeURIComponent(url.split('/').pop() || url);
			if (decoded === normalizedTarget) {
				// we will asynchronously fulfill this XHR
				combinedBufferPromise.then((buf) => {
					// If responseType is set to 'arraybuffer' or '' or '': set properties and call handlers
					if (this.responseType === '' || this.responseType === 'arraybuffer' || this.responseType === 'blob') {
						// set readyState and response properties in a minimal way
						this.readyState = 4;
						try { this.status = 200; } catch {}
						try {
							if (this.responseType === 'blob') {
								this.response = new Blob([buf]);
							} else {
								this.response = buf;
							}
							this.responseText = null;
						} catch (e) {
							// ignore
						}
					}
					// call handlers if present
					if (typeof this.onload === 'function') {
						this.onload({ target: this });
					}
					if (typeof this.onreadystatechange === 'function') {
						this.onreadystatechange({ target: this });
					}
				}).catch(err => {
					// emulate error
					if (typeof this.onerror === 'function') this.onerror(err);
				});
				return; // skip the real send
			}
		} catch (e) {
			console.warn("XHR interceptor error:", e);
		}
		return _origXhrSend.apply(this, arguments);
	};
}

(function () {
	const INDETERMINATE_STATUS_STEP_MS = 100;
	const statusProgress = document.getElementById('status-progress');
	const statusProgressInner = document.getElementById('status-progress-inner');
	const statusIndeterminate = document.getElementById('status-indeterminate');
	const statusNotice = document.getElementById('status-notice');

	let initializing = true;
	let statusMode = 'hidden';

	let animationCallbacks = [];
	function animate(time) {
		animationCallbacks.forEach((callback) => callback(time));
		requestAnimationFrame(animate);
	}
	requestAnimationFrame(animate);

	function animateStatusIndeterminate(ms) {
		const i = Math.floor((ms / INDETERMINATE_STATUS_STEP_MS) % 8);
		if (statusIndeterminate.children[i].style.borderTopColor === '') {
			Array.prototype.slice.call(statusIndeterminate.children).forEach((child) => {
				child.style.borderTopColor = '';
			});
			statusIndeterminate.children[i].style.borderTopColor = '#dfdfdf';
		}
	}

	function setStatusMode(mode) {
		if (statusMode === mode || !initializing) {
			return;
		}
		[statusProgress, statusIndeterminate, statusNotice].forEach((elem) => {
			elem.style.display = 'none';
		});
		animationCallbacks = animationCallbacks.filter(function (value) {
			return (value !== animateStatusIndeterminate);
		});
		switch (mode) {
		case 'progress':
			statusProgress.style.display = 'block';
			break;
		case 'indeterminate':
			statusIndeterminate.style.display = 'block';
			animationCallbacks.push(animateStatusIndeterminate);
			break;
		case 'notice':
			statusNotice.style.display = 'block';
			break;
		case 'hidden':
			break;
		default:
			throw new Error('Invalid status mode');
		}
		statusMode = mode;
	}

	function setStatusNotice(text) {
		while (statusNotice.lastChild) {
			statusNotice.removeChild(statusNotice.lastChild);
		}
		const lines = text.split('\n');
		lines.forEach((line) => {
			statusNotice.appendChild(document.createTextNode(line));
			statusNotice.appendChild(document.createElement('br'));
		});
	}

	function displayFailureNotice(err) {
		const msg = err && err.message ? err.message : String(err);
		console.error(msg);
		setStatusNotice(msg);
		setStatusMode('notice');
		initializing = false;
	}

	// If the environment is missing browser features, show the original error immediately.
	const missing = Engine.getMissingFeatures ? Engine.getMissingFeatures() : [];
	if (missing.length !== 0) {
		const missingMsg = 'Error\nThe following features required to run Godot projects on the Web are missing:\n';
		displayFailureNotice(missingMsg + missing.join('\n'));
		return;
	}

	// Start combining parts, show progress
	setStatusMode('indeterminate');

	const combinedPromise = fetchAndCombineParts(BASE_PCK_NAME, PART_COUNT, (cur, tot) => {
		statusProgressInner.style.width = `${(cur / tot) * 100}%`;
		setStatusMode('progress');
		if (cur === tot) {
			setTimeout(() => setStatusMode('indeterminate'), 250);
		}
	}).then((buffer) => {
		// Done combining
		setStatusMode('indeterminate');

		// Install interceptors so any request for the original .pck filename returns the combined buffer
		installInterceptors(BASE_PCK_NAME, Promise.resolve(buffer));

		// Now instantiate the engine and start the game
		const engine = new Engine(GODOT_CONFIG);
		return engine.startGame({
			'onProgress': function (current, total) {
				if (total > 0) {
					statusProgressInner.style.width = `${(current / total) * 100}%`;
					setStatusMode('progress');
					if (current === total) {
						setTimeout(() => setStatusMode('indeterminate'), 500);
					}
				} else {
					setStatusMode('indeterminate');
				}
			},
		}).then(() => {
			setStatusMode('hidden');
			initializing = false;
		}, displayFailureNotice);
	}).catch(displayFailureNotice);

	// keep a reference so devtools can inspect the promise if needed
	window.__pckCombinePromise = combinedPromise;
}());
</script>
